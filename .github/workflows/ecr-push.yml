name: Build and Push to ECR

on:
  push:
    branches: [ main ]

permissions:
  id-token: write   # Required for OIDC
  contents: read    # Required for checkout

env:
  AWS_REGION: ${{ vars.AWS_REGION }}
  ECR_REGISTRY: ${{ vars.ECR_REGISTRY }}
  ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY }}
  EC2_HOST: ${{ vars.EC2_HOST }}
  EC2_USER: ${{ vars.EC2_USER }}
  APP_DIR: ${{ vars.APP_DIR }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::683684736241:role/GitHubActionsOliviaConciliationRole
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push backend
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          no-cache: true
          tags: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:backend-latest

      - name: Build and push frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          no-cache: true
          tags: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:frontend-latest

  deploy-ec2:
    runs-on: ubuntu-latest
    needs: build-and-push
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::683684736241:role/GitHubActionsOliviaConciliationRole
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to EC2 via SSM
        run: |
          # Encode files to base64 to pass them easily via SSM
          DOCKER_COMPOSE_B64=$(base64 -w 0 docker-compose.yml)
          DEPLOY_SCRIPT_B64=$(base64 -w 0 scripts/deploy-ec2.sh)
          NGINX_CONF_B64=$(base64 -w 0 nginx/nginx.conf)
          SETUP_SSL_B64=$(base64 -w 0 scripts/setup-ssl.sh)

          # Busca o InstanceId dinamicamente pela tag (usando variáveis com fallback)
          TAG_KEY="${{ vars.DEPLOY_TAG_KEY || 'Project' }}"
          TAG_VALUE="${{ vars.DEPLOY_TAG_VALUE || 'Olivia' }}"

          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:$TAG_KEY,Values=$TAG_VALUE" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)

          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" == "None" ]; then
            echo "Erro: Nenhuma instância rodando encontrada com a tag Project=Olivia"
            exit 1
          fi

          echo "Iniciando deploy via SSM na instância $INSTANCE_ID..."

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy Olivia Conciliation" \
            --parameters 'commands=[
              "mkdir -p ${{ env.APP_DIR }}/scripts ${{ env.APP_DIR }}/nginx",
              "echo '"$DOCKER_COMPOSE_B64"' | base64 -d > ${{ env.APP_DIR }}/docker-compose.new",
              "echo '"$DEPLOY_SCRIPT_B64"' | base64 -d > ${{ env.APP_DIR }}/scripts/deploy-ec2.sh",
              "echo '"$NGINX_CONF_B64"' | base64 -d > ${{ env.APP_DIR }}/nginx/nginx.conf",
              "echo '"$SETUP_SSL_B64"' | base64 -d > ${{ env.APP_DIR }}/scripts/setup-ssl.sh",
              "chmod +x ${{ env.APP_DIR }}/scripts/deploy-ec2.sh ${{ env.APP_DIR }}/scripts/setup-ssl.sh",
              "export APP_DIR=${{ env.APP_DIR }}",
              "export AWS_REGION=${{ env.AWS_REGION }}",
              "export ECR_REGISTRY=${{ env.ECR_REGISTRY }}",
              "export ECR_REPOSITORY=${{ env.ECR_REPOSITORY }}",
              "export GCP_SERVICE_ACCOUNT_KEY=\"${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}\"",
              "export SPREADSHEET_ID=\"${{ secrets.SPREADSHEET_ID }}\"",
              "export PLUGGY_CLIENT_ID=\"${{ secrets.PLUGGY_CLIENT_ID }}\"",
              "export PLUGGY_CLIENT_SECRET=\"${{ secrets.PLUGGY_CLIENT_SECRET }}\"",
              "export ADMIN_USER=\"${{ secrets.ADMIN_USER }}\"",
              "export ADMIN_PASS=\"${{ secrets.ADMIN_PASS }}\"",
              "export JWT_SECRET=\"${{ secrets.JWT_SECRET }}\"",
              "${{ env.APP_DIR }}/scripts/deploy-ec2.sh"
            ]' \
            --query "Command.CommandId" \
            --output text)

          echo "Comando enviado! ID: $COMMAND_ID"
          echo "Aguardando conclusão..."

          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID"

          # Verifica se o comando teve sucesso
          STATUS=$(aws ssm list-command-invocations \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "CommandInvocations[0].Status" \
            --output text)

          if [ "$STATUS" != "Success" ]; then
            echo "Erro no deploy! Status: $STATUS"
            aws ssm list-command-invocations \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --details \
              --query "CommandInvocations[0].CommandPlugins[0].Output" \
              --output text
            exit 1
          fi

          echo "Deploy finalizado com sucesso via SSM!"